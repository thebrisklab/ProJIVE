---
title: "ProJIVE and CJIVE"
output: rmarkdown::github_document
---
# Short Introudction
This document serves as an illustrative example of JIVE analysis using both Canonical JIVE (i.e. CJIVE which is equivalent to AJIVE given the same joint and individual ranks) and the EM algorithm-based ProJIVE. Details of the ProJIVE model for JIVE analyses can be found in the Probabilistic JIVE manuscript. Here, we use simulated (i.e. toy) data to compare. In order to follow along with the analyses presented herein, please make sure to download the file "Functions_to_SimulateData.R" from our GitHub page github.com/BenjaminRisk/ProJIVE and save it in the same directory as this document. Both the program to simulate data and ProJIVE are currently designed to handle exactly $K = 2$ data sets.

```{r setup, include=FALSE}
# NOTE: Change the location of 'prog.dir' to the location where you have saved the file 'Functions_to_SimulateData.R'
# NOTE: Change the location of 'prog.dir' to the location where you have saved the file 'Functions_to_SimulateData.R'
prog.dir = "H:/My Documents/P-JIVE/Programs/Functions"
source(file.path(prog.dir, "Functions_for_CJIVE.R"))
source(file.path(prog.dir, "Functions_for_PJIVE.R"))
set.seed(0)

```

## Input Parameters
Input parameters for generating data include the following quantities: $n$ - number of subjects; $p_k$ - number of features in $k^{th}$ data block ($k=1,2$); $r_J$ - joint rank; $r_{Ik}$ - individual rank for $k^{th}$ data block; $R_{Jk}^2$ - proportion of total variation n $k^{th}$ data block attributable to the joint signal; $R_{Ik}^2$ - proportion of total variation n $k^{th}$ data block attributable to it's individual signal. Note: the last parameters described were portions and therefore require $R_{Jk}^2 + R_{Ik}^2 \leq 1$ for each $k$. The use may also set a 'seed number.' We use seed number = 0.

```{r, echo = TRUE}
# Sample size and number of features per block
n = 100
p1 = 30
p2 = 50 

# Ranks (joint, followed by individual rank for each block)
r.J = 1
r.I1 = 2
r.I2 = 2

# Proportions of joint variation explained
JntVarEx1 = 0.05 
JntVarEx2 = 0.5

# Proportions of individual variation explained
IndVarEx1 = 0.25
IndVarEx2 = 0.25
```

## Simulated Toy Datasets
In addition to the input parameters defined above, the function "GenToyDatBinRank" has the following parameters: 
'equal.eig' - logical (TRUE/FALSE), which allows the user to specify whether components within a data-blocks joint (or individual) signal should be equally waited. The default is FALSE

'JntVarAdj' - logical (TRUE/FALSE): Specify whether signal matrices should be weighted to achieve the desired proportions of variation attributable to the joint signal

'SVD.plots' - logical (TRUE/FALSE): Should plots of signal matrix singular values be produced to verify ranks?

'Error' - logical (TRUE/FALSE): Should the data be noise-contaminated?

'print.cor' - logical (TRUE/FALSE), Print the correlation matrix for the scores? (Allows check for orthoganility between scores/compnents)

'Loads' - char: Toy data can be generated with loadings from 'Gaussian', 'Rademacher', or 'Double_Exp'  (double exponential) distributions. Loadings can also be fixed at binary (0/1) values assigned to half of the variables

'Scores' - char: Scores can be randomly generated from 'Gaussian', 'Binomial', or 'Gaussian_Mixture' distributions. 

```{r, echo = TRUE}
true_signal_ranks = r.J + c(r.I1,r.I2)                          ##true ranks of overall signals
ToyDat = GenerateToyData(n = n, p1 = p1, p2 = p2, JntVarEx1 = JntVarEx1, JntVarEx2 = JntVarEx2, 
                         IndVarEx1 = IndVarEx1, IndVarEx2 =  IndVarEx2, jnt_rank = r.J,
                         equal.eig = F,ind_rank1 = r.I1, ind_rank2 = r.I2, JntVarAdj = T, SVD.plots = T,
                         Error = T, print.cor = F, Loads = "Gaussian", Scores = "Gaussian")
```

```{r, echo = FALSE}
blocks <- ToyDat[[2]]

##Setup input parameters to use Gavin's EM code
Y = do.call(cbind, blocks); P = c(p1, p2); Q = c(r.J,r.I1,r.I2)

# Theta
JntScores = ToyDat[['Scores']][['Joint']]
IndivScore.X = ToyDat[['Scores']][["Indiv_1"]]
IndivScore.Y = ToyDat[['Scores']][["Indiv_2"]]

# WJ1 and WJ2
JntLd.X = t(ToyDat[['Loadings']][["Joint_1"]])
JntLd.Y = t(ToyDat[['Loadings']][["Joint_2"]])

# WI1 and WI2
IndivLd.X =t(ToyDat[['Loadings']][["Indiv_1"]])
IndivLd.Y = t(ToyDat[['Loadings']][["Indiv_2"]])
```

```{r, echo = FALSE}
# Signal matrices
JX = ToyDat[[1]]$J1
JY = ToyDat[[1]]$J2
IX = ToyDat[[1]]$I1
IY = ToyDat[[1]]$I2
## Proportions of variation explained
JVE.X = MatVar(JX)/MatVar(blocks[[1]])
JVE.Y = MatVar(JY)/MatVar(blocks[[2]])

IVE.X = MatVar(IX)/MatVar(blocks[[1]])
IVE.Y = MatVar(IY)/MatVar(blocks[[2]])

TotVE.X = MatVar((JX + IX))/MatVar(blocks[[1]])
TotVE.Y = MatVar((JY + IY))/MatVar(blocks[[2]])

```

Check that values of $R_{Jk}^2$ and $R_{Ik}^2$ in the simulated data match the desired quantities.
```{r, echo = FALSE}
bquote(paste(R[JX]^2, '=' , .(round(JVE.X,4))))
bquote(paste(R[JY]^2, '=' , .(round(JVE.X,4))))
bquote(paste(R[IX]^2, '=' , .(round(IVE.X,4))))
bquote(paste(R[IY]^2, '=' , .(round(IVE.X,4))))
```

Now, compute the CJIVE solution and graph joint subject scores (not individual scores) in addition to joint and individual loadings.
```{r, echo = TRUE}
#### CJIVE
CJIVE.res = cc.jive(blocks, true_signal_ranks, r.J, perm.test = FALSE)

# CJIVE signal matrix estimates
J.hat = CJIVE.res$sJIVE$joint_matrices
I.hat = CJIVE.res$sJIVE$indiv_matrices

# CJIVE loading estimates
WJ = lapply(J.hat, function(x) x[['v']])
WI = lapply(I.hat, function(x) x[['v']])
```

```{r, echo = FALSE}
# Plots of CJIVE estimates against true counterparts
layout(matrix(1:6,2, byrow = TRUE))
plot(JntScores, CJIVE.res$CanCorRes$Jnt_Scores, xlab = "True Joint Scores",ylab = "CJIVE Joint Scores", 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(JntScores, CJIVE.res$CanCorRes$Jnt_Scores), 3)))
plot(JntLd.X, WJ[[1]], xlab = "True Joint Loadings X", ylab = "CJIVE Joint Loadings X", 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(JntLd.X, WJ[[1]]), 3)))
plot(JntLd.Y, WJ[[2]], xlab = "True Joint Loadings Y", ylab = "CJIVE Joint Loadings Y", 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(JntLd.Y, WJ[[2]]), 3)))
# plot(1,lwd=0,axes=F,xlab="",ylab="", "n")
plot.new(); legend("left", paste("Comp.", 1:2), pch = 1, col  = c("orange", "green"),bty = "n" )
plot(IndivLd.X, WI[[1]], xlab = "True Individual Loadings X", ylab = "CJIVE Individual Loadings X", 
     col = c(rep("orange",p1), rep("green",p2)), 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(IndivLd.X, WI[[1]]), 3)))
plot(IndivLd.Y, WI[[2]], xlab = "True Individual Loadings Y", ylab = "CJIVE Individual Loadings Y", 
     col = c(rep("orange",p1), rep("green",p2)), 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(IndivLd.Y, WI[[2]]), 3)))
layout(1)
```

Now, compute the PJIVE solution and graph joint subject scores (not individual scores) in addition to joint and individual loadings.
```{r, echo = TRUE}
##### ProJIVE
PJIVE.res = ProJIVE_EM(Y=Y, P=P, Q=Q, Max.iter=10000, diff.tol=1e-5)

PJIVE.scores = PJIVE.res$SubjectScoreMatrix
PJIVE.loads.X = PJIVE.res$LoadingMatrix[1:p1,-(sum(Q):(sum(Q[-3])+1))]
PJIVE.loads.Y = PJIVE.res$LoadingMatrix[-(1:p1),-(r.J+1:r.I1)]
```

```{r, echo = FALSE}
layout(matrix(1:6,2, byrow = TRUE))
plot(JntScores, PJIVE.scores[,1:r.J], xlab = "True Joint Scores", ylab = "ProJIVE Joint Scores", 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(JntScores, PJIVE.scores), 3)))
plot(JntLd.X, PJIVE.loads.X[,1:r.J], xlab = "True Joint Loadings X", ylab = "ProJIVE Joint Loadings X", 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(JntLd.X, PJIVE.loads.X[,1:r.J]), 3)))
plot(JntLd.Y, PJIVE.loads.Y[,1:r.J], xlab = "True Joint Loadings Y", ylab = "ProJIVE Joint Loadings Y", 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(JntLd.Y, PJIVE.loads.Y[,1:r.J]), 3)))

# plot(1,lwd=0,axes=F,xlab="",ylab="", "n")
plot.new(); legend("left", paste("Comp.", 1:2), pch = 1, col  = c("orange", "green"),bty = "n" )
plot(IndivLd.X, PJIVE.loads.X[,-(1:r.J)], xlab = "True Individual Loadings X", ylab = "ProJIVE Individual Loadings X", 
     col = c(rep("orange",p1), rep("green",p2)), 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(IndivLd.X, PJIVE.loads.X[,-(1:r.J)]), 3)))
plot(IndivLd.Y, PJIVE.loads.Y[,-(1:r.J)], xlab = "True Individual Loadings Y", ylab = "ProJIVE Individual Loadings Y", 
     col = c(rep("orange",p1), rep("green",p2)), 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(IndivLd.Y, PJIVE.loads.Y[,-(1:r.J)]), 3)))
layout(1)
```

## Gaussian Mixture Scores
When study participants can be categorized due to an exogenous variable that is associated with the joint sources of variation (i.e. diagnosis categories, etc.), joint subject scores may be used to categorize participants. The code snippet here generates toy data that reflect this scenario by taking joint subject scores from Gaussian mixture model.
```{r, echo = TRUE}
true_signal_ranks = r.J + c(r.I1,r.I2)                          ##true ranks of overall signals
ToyDat = GenerateToyData(n = n, p1 = p1, p2 = p2, JntVarEx1 = JntVarEx1, JntVarEx2 = JntVarEx2, 
                         IndVarEx1 = IndVarEx1, IndVarEx2 =  IndVarEx2, jnt_rank = r.J,
                         equal.eig = F,ind_rank1 = r.I1, ind_rank2 = r.I2, JntVarAdj = T, SVD.plots = T,
                         Error = T, print.cor = F, Loads = "Gaussian", Scores = "Gaussian_Mixture")
```

```{r, echo = FALSE}
blocks <- ToyDat[[2]]

##Setup input parameters to use Gavin's EM code
Y = do.call(cbind, blocks); P = c(p1, p2); Q = c(r.J,r.I1,r.I2)

# Theta
JntScores = ToyDat[['Scores']][['Joint']]
IndivScore.X = ToyDat[['Scores']][["Indiv_1"]]
IndivScore.Y = ToyDat[['Scores']][["Indiv_2"]]

# WJ1 and WJ2
JntLd.X = t(ToyDat[['Loadings']][["Joint_1"]])
JntLd.Y = t(ToyDat[['Loadings']][["Joint_2"]])

# WI1 and WI2
IndivLd.X =t(ToyDat[['Loadings']][["Indiv_1"]])
IndivLd.Y = t(ToyDat[['Loadings']][["Indiv_2"]])
```

```{r, echo = FALSE}
# Signal matrices
JX = ToyDat[[1]]$J1
JY = ToyDat[[1]]$J2
IX = ToyDat[[1]]$I1
IY = ToyDat[[1]]$I2
## Proportions of variation explained
JVE.X = MatVar(JX)/MatVar(blocks[[1]])
JVE.Y = MatVar(JY)/MatVar(blocks[[2]])

IVE.X = MatVar(IX)/MatVar(blocks[[1]])
IVE.Y = MatVar(IY)/MatVar(blocks[[2]])

TotVE.X = MatVar((JX + IX))/MatVar(blocks[[1]])
TotVE.Y = MatVar((JY + IY))/MatVar(blocks[[2]])

```

Check that values of $R_{Jk}^2$ and $R_{Ik}^2$ in the simulated data match the desired quantities.
```{r, echo = FALSE}
bquote(paste(R[JX]^2, '=' , .(round(JVE.X,4))))
bquote(paste(R[JY]^2, '=' , .(round(JVE.X,4))))
bquote(paste(R[IX]^2, '=' , .(round(IVE.X,4))))
bquote(paste(R[IY]^2, '=' , .(round(IVE.X,4))))
```

Now, compute the CJIVE solution and graph joint subject scores (not individual scores) in addition to joint and individual loadings.
```{r, echo = TRUE}
#### CJIVE
CJIVE.res = cc.jive(blocks, true_signal_ranks, r.J, perm.test = FALSE)

# CJIVE signal matrix estimates
J.hat = CJIVE.res$sJIVE$joint_matrices
I.hat = CJIVE.res$sJIVE$indiv_matrices

# CJIVE loading estimates
WJ = lapply(J.hat, function(x) x[['v']])
WI = lapply(I.hat, function(x) x[['v']])
```

```{r, echo = FALSE}
# Plots of CJIVE estimates against true counterparts
layout(matrix(1:6,2, byrow = TRUE))
plot(JntScores, CJIVE.res$CanCorRes$Jnt_Scores, xlab = "True Joint Scores",ylab = "CJIVE Joint Scores", 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(JntScores, CJIVE.res$CanCorRes$Jnt_Scores), 3)))
plot(JntLd.X, WJ[[1]], xlab = "True Joint Loadings X", ylab = "CJIVE Joint Loadings X", 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(JntLd.X, WJ[[1]]), 3)))
plot(JntLd.Y, WJ[[2]], xlab = "True Joint Loadings Y", ylab = "CJIVE Joint Loadings Y", 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(JntLd.Y, WJ[[2]]), 3)))
# plot(1,lwd=0,axes=F,xlab="",ylab="", "n")
plot.new(); legend("left", paste("Comp.", 1:2), pch = 1, col  = c("orange", "green"),bty = "n" )
plot(IndivLd.X, WI[[1]], xlab = "True Individual Loadings X", ylab = "CJIVE Individual Loadings X", 
     col = c(rep("orange",p1), rep("green",p2)), 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(IndivLd.X, WI[[1]]), 3)))
plot(IndivLd.Y, WI[[2]], xlab = "True Individual Loadings Y", ylab = "CJIVE Individual Loadings Y", 
     col = c(rep("orange",p1), rep("green",p2)), 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(IndivLd.Y, WI[[2]]), 3)))
layout(1)
```

Now, compute the PJIVE solution and graph joint subject scores (not individual scores) in addition to joint and individual loadings.
```{r, echo = TRUE}
##### ProJIVE
PJIVE.res = ProJIVE_EM(Y=Y, P=P, Q=Q, Max.iter=1000, diff.tol=1e-5)

PJIVE.scores = PJIVE.res$SubjectScoreMatrix
PJIVE.loads.X = PJIVE.res$LoadingMatrix[1:p1,-(sum(Q):(sum(Q[-3])+1))]
PJIVE.loads.Y = PJIVE.res$LoadingMatrix[-(1:p1),-(r.J+1:r.I1)]
```

```{r, echo = FALSE}
layout(matrix(1:6,2, byrow = TRUE))
plot(JntScores, PJIVE.scores[,1:r.J], xlab = "True Joint Scores", ylab = "ProJIVE Joint Scores", 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(JntScores, PJIVE.scores), 3)))
plot(JntLd.X, PJIVE.loads.X[,1:r.J], xlab = "True Joint Loadings X", ylab = "ProJIVE Joint Loadings X", 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(JntLd.X, PJIVE.loads.X[,1:r.J]), 3)))
plot(JntLd.Y, PJIVE.loads.Y[,1:r.J], xlab = "True Joint Loadings Y", ylab = "ProJIVE Joint Loadings Y", 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(JntLd.Y, PJIVE.loads.Y[,1:r.J]), 3)))

# plot(1,lwd=0,axes=F,xlab="",ylab="", "n")
plot.new(); legend("left", paste("Comp.", 1:2), pch = 1, col  = c("orange", "green"),bty = "n" )
plot(IndivLd.X, PJIVE.loads.X[,-(1:r.J)], xlab = "True Individual Loadings X", ylab = "ProJIVE Individual Loadings X", 
     col = c(rep("orange",p1), rep("green",p2)), 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(IndivLd.X, PJIVE.loads.X[,-(1:r.J)]), 3)))
plot(IndivLd.Y, PJIVE.loads.Y[,-(1:r.J)], xlab = "True Individual Loadings Y", ylab = "ProJIVE Individual Loadings Y", 
     col = c(rep("orange",p1), rep("green",p2)), 
     sub = paste0("Chordal Norm = ", round(chord.norm.diff(IndivLd.Y, PJIVE.loads.Y[,-(1:r.J)]), 3)))
layout(1)
```

We can also check the histogram of joint scores from each method for the multimodality that arises from Gaussian mixtures and check that there is a statisically significant association between joint scores and group asignment based on the miture model. 
```{r, echo = TRUE}
## Proportions of groups for mixture
mix.probs = c(0.2, 0.5, 0.3)
n.mix = n*mix.probs
mix.group = factor(c(rep(1, n.mix[1]),rep(2, n.mix[2]),rep(3, n.mix[3])))
JntScores.dat = data.frame(V1 = c(CJIVE.res$CanCorRes$Jnt_Scores, PJIVE.scores[,1:r.J]))
JntScores.dat$group = factor(c(mix.group, mix.group), labels = paste("Group", 1:3))
JntScores.dat$Method = factor(rep(1:2, each = n), labels = c("CJIVE", "ProJIVE"))
ggplot(data = JntScores.dat, aes(V1, fill = group)) + geom_histogram(bins = 20, position = "dodge") + facet_wrap(Method~.)
```
